#include <unistd.h>
#include <stdlib.h>
#include <time.h>

#include "config.h"

#include "pthread.h"
#include "echolib.h"
#include "checks.h"

#define QUEUE_SIZE 100
#define DEFAULT_WORKER_NUM 4
#define DEFAULT_WORK_SLICE_SIZE 20

typedef struct _data{
  int * inarr;
  int * outarr;
  int start;
  int size;
  int * flag_arr;
  int flag_pos;
  struct _data * rear_dir;
  struct _data * front_dir;
} qdata;

typedef struct _Queue {
  int size;
  qdata * front, *rear;
  int tried;
} Queue;

struct workerArg{
  int index;
};

struct acceptorArg{
  int sockfd;
};

Queue* queues;

int workerThreadSize = DEFAULT_WORKER_NUM;
int qslice_max_size = DEFAULT_WORK_SLICE_SIZE;

pthread_mutex_t * qu_mutexs;
pthread_mutex_t conn_mutex;
pthread_barrier_t bar;

void
serve_connection (int sockfd);

void* server_handoff_to_acceptor(void * arg);

void add_queue(Queue* q, qdata data);
qdata pop_queue(Queue* q);
int check_queue_emtpy(Queue* q);
//int check_queue_full(Queue* q);

void * workfunc(void *);


/* the main per-connection service loop of the server; assumes
   sockfd is a connected socket */
void
  serve_connection (int sockfd) {
  //pthread_mutex_lock(&conn_mutex);
  connection_t conn;
  connection_init (&conn);
  conn.sockfd = sockfd;
  //pthread_mutex_unlock(&conn_mutex);

  int N; int ACK=1;
  int * input_arr;
  int * output_arr;
  int * result_flags;

  while (! shutting_down) {
    if (read (sockfd, (void *)&N, sizeof(int)) <= 0) goto quit;
    if (shutting_down) goto quit;

    if (write(sockfd, (void*)&ACK, sizeof(int)) <= 0) goto quit;
    if (shutting_down) goto quit;

    input_arr = malloc(sizeof(int) * N);
    output_arr = malloc(sizeof(int) * N);

    if (read (sockfd, (void*)input_arr, sizeof(int) * N) <= 0) goto quit;
    if (shutting_down) goto quit;

    int block_num = ((N-1)/qslice_max_size) + 1;
    result_flags = malloc(sizeof(int)*block_num);
    memset((void*)result_flags, 0, block_num);

    int in = rand()%workerThreadSize;
    for(int i=0;i<N;i+=qslice_max_size){
      //make data
      qdata d;
      d.inarr = input_arr;
      d.outarr = output_arr;
      d.start = i;
      d.size = qslice_max_size;
      if(i + qslice_max_size > N ){
        d.size = N%qslice_max_size;
      }
      d.flag_arr = result_flags;
      d.flag_pos = i/qslice_max_size;

      //add request
      pthread_mutex_lock(&qu_mutexs[in]);
      add_queue(&queues[in],d);
      pthread_mutex_unlock(&qu_mutexs[in]);
      in = (in +1)%workerThreadSize;
    }

    for(int i=0;i<block_num;i++){
      while(result_flags[i] ==0){}
    }

    if (write(sockfd, (void*)output_arr, sizeof(int) * N) <= 0) goto quit;
    if (shutting_down) goto quit;

    // free(input_arr);
    // free(output_arr);
    // free(result_flags);
  }
quit:
  //pthread_mutex_lock(&conn_mutex);
  CHECK (close (sockfd));
  //pthread_mutex_unlock(&conn_mutex);
}

/* set up socket to use in listening for connections */
void
open_listening_socket (int *listenfd) {
  struct sockaddr_in servaddr;
  const int server_port = 0; /* use ephemeral port number */
  socklen_t namelen;
  memset (&servaddr, 0, sizeof(struct sockaddr_in));
  servaddr.sin_family = AF_INET;
  /* htons translates host byte order to network byte order; ntohs
     translates network byte order to host byte order */
  servaddr.sin_addr.s_addr = htonl (INADDR_ANY);
  servaddr.sin_port = htons (server_port);
  /* create the socket */
  CHECK (*listenfd = socket(AF_INET, SOCK_STREAM, 0))
  /* bind it to the ephemeral port number */
  CHECK (bind (*listenfd, (struct sockaddr *) &servaddr, sizeof (servaddr)));
  /* extract the ephemeral port number, and put it out */
  namelen = sizeof (servaddr);
  CHECK (getsockname (*listenfd, (struct sockaddr *) &servaddr, &namelen));
  fprintf (stderr, "server using port %d\n", ntohs(servaddr.sin_port));
}

/* handler for SIGINT, the signal conventionally generated by the
   control-C key at a Unix console, to allow us to shut down
   gently rather than having the entire process killed abruptly. */ 
void
siginthandler (int sig, siginfo_t *info, void *ignored) {
  shutting_down = 1;
} 

void
install_siginthandler () {
  struct sigaction act;
  /* get current action for SIGINT */
  CHECK (sigaction (SIGINT, NULL, &act));
  /* add our handler */
  act.sa_sigaction = siginthandler;
  /* update action for SIGINT */
  CHECK (sigaction (SIGINT, &act, NULL));
}

void add_queue(Queue* q, qdata d) {
  
  qdata * temp = malloc(sizeof(qdata));
  *temp = d;

  if(q->size ==0){
	  q->front = temp;
	  q->rear = temp;
  }
  else{
	  q->rear->rear_dir = temp;
	  d.front_dir = q->rear;
	  q->rear = temp;
  }
  q->size++;
}

qdata pop_queue(Queue* q) { //you must free poped element after pop_queue.
  if(q->size ==0){
	printf("pop fail, queue is empty.\n please check size before pop.");
	exit(1);
  }
  else{
	qdata poped = *q->front;
    if(q->size !=1){
		q->front = q->front->rear_dir;
	  }
    else {
      q->front = q->rear = NULL;
    }
	q->size --;
	return poped;
  }

}

int check_queue_emtpy(Queue* q){
  if(q->size == 0) {return 1;}
  else{return 0;}
}
/*int check_queue_full(Queue* q){
  if(q->front == (q->rear + 1) % QUEUE_SIZE) {return 1;}
  else {return 0;}
}*/

void
set_worker_num () {
  char * p;
  if ((p = getenv ("SERVER_WORKER_NUM"))) {
    sscanf (p, "%d", &workerThreadSize);
  }
}

void
set_slice_size () {
  char * p;
  if ((p = getenv ("SERVER_SLICE_SiZE"))) {
    sscanf (p, "%d", &qslice_max_size);
  }
}



int
main (int argc, char **argv) {
  int connfd, listenfd;
  socklen_t clilen;
  struct sockaddr_in cliaddr;
  srand(time(NULL));
  set_worker_num();
  set_slice_size();

  int param_opt;
  while(-1 !=(param_opt = getopt(argc, argv, "n:k:"))){
		switch(param_opt){
      case 'n' : workerThreadSize = atoi(optarg);
      case 's' : qslice_max_size = atoi(optarg);
		}
	}
 
  qu_mutexs = (pthread_mutex_t *)malloc(sizeof(pthread_mutex_t)*workerThreadSize);
  for(int i=0;i<workerThreadSize;i++){
    pthread_mutex_init(&qu_mutexs[i], NULL);
  }
  pthread_mutex_init(&conn_mutex, NULL);
  pthread_barrier_init(&bar, NULL, workerThreadSize);

  queues = (Queue*)malloc(sizeof(Queue)*workerThreadSize);
  //return_queues = (Queue*)malloc(sizeof(Queue)*workerThreadSize);

  pthread_t * workerThreads = (pthread_t*) malloc (sizeof(pthread_t)*workerThreadSize);

  for(int i=0; i<workerThreadSize; i++) {
    queues[i].size = 0;
    
    struct workerArg * wa = (struct workerArg *) malloc(sizeof(struct workerArg));
    wa->index = i;
    pthread_create(&workerThreads[i], NULL, workfunc, (void*)wa);
  }

  install_siginthandler();
  open_listening_socket (&listenfd);
  CHECK (listen (listenfd, 1000));
  /* allow up to 4 queued connection requests before refusing */
  while (! shutting_down) {
    
    //pthread_mutex_lock(&conn_mutex);
    errno = 0;
    clilen = sizeof (cliaddr); /* length of address can vary, by protocol */  
    connfd = accept (listenfd, (struct sockaddr *) &cliaddr, &clilen);
    //pthread_mutex_unlock(&conn_mutex);
    if (connfd < 0) {
      if (errno != EINTR) ERR_QUIT ("accept"); 
      /* otherwise try again, unless we are shutting down */
    }
     else {

    //server_handoff (connfd);
    struct acceptorArg * aa = (struct acceptorArg *) malloc(sizeof(struct acceptorArg));
    aa->sockfd = connfd;
    pthread_t th;
    pthread_create(&th, NULL, server_handoff_to_acceptor, (void*)aa);
    //serve_connection (connfd);
    //sleep(2);
    }
  }
  //pthread_mutex_lock(&conn_mutex);
  //CHECK (close (listenfd));
  //pthread_mutex_unlock(&conn_mutex);

  //pthread_mutex_lock(&conn_mutex);
  CHECK (close (listenfd));
  //pthread_mutex_unlock(&conn_mutex);

  return 0;
}


void* server_handoff_to_acceptor(void* arg){
  //int* sockfd = (int*)arg;
  
  struct acceptorArg * warg = (struct acceptorArg *) arg;
  int sockfd = warg->sockfd;
  free(arg);
  
  serve_connection (sockfd);
  // return NULL;
}

//han taehui code
int isPrime(int n){
    for(int i = 2 ; i*i < n ; i++){
    if(n % i == 0) return 0;
  }
  return 1;
}

void * workfunc(void * voidarg){
  struct workerArg * arg = (struct workerArg *) voidarg;
  int index = arg->index;
  free(arg);
  int can_steal = 1;
  int wait_count = 0;

  while(1){
    qdata d;
    int get_job = 0;
    pthread_mutex_lock(&qu_mutexs[index]);
    if (!check_queue_emtpy(&queues[index])){ //local_work_exit
      d = pop_queue(&queues[index]);
      get_job = 1;
    }
    pthread_mutex_unlock(&qu_mutexs[index]);
    
    /*
    if(!can_steal && (wait_count++ > 1000)) {
      can_steal = 1;
      wait_count = 0;
    }
    //stealing
    
    if(!get_job && index != (workerThreadSize - 1) && can_steal) {
      int next_index = (index + 1) % workerThreadSize;

      pthread_mutex_lock(&qu_mutexs[index]);
      // printf("worker[%d] lock self.\n", index);
      pthread_mutex_lock(&qu_mutexs[next_index]);
      // printf("worker[%d] lock next.\n", index);

      if(queues[next_index].size >= 4) {
        // printf("queue[%d] is empty, need to steal [%d]. next q size : %d\n", index, next_index,
        // queues[next_index].size);
        queues[index].rear = queues[next_index].rear;

        qdata* temp = queues[next_index].rear;
        if(queues[next_index].size == 2) {
          queues[index].front = temp;
          queues[index].rear = temp;
          queues[index].size = 1;
          queues[next_index].size = 1;
          // printf("now queues[%d] size is : %d, next index queue size is :%d\n", 
          // index, queues[index].size, queues[next_index].size);
        }
        else {
          for(int i=0; i<queues[next_index].size/2; i++) {
            temp = temp->front_dir;
          }
          queues[index].front = temp;
          queues[next_index].rear = temp->front_dir;
          queues[index].size = queues[next_index].size/2 + 1;
          queues[next_index].size -= queues[index].size;
          // printf("now queues[%d] size is : %d, next index queue size is :%d\n", 
          // index, queues[index].size, queues[next_index].size);
        }
        can_steal = 1;
      }
      else {
        if(queues[index].tried++ >= 10) {
        // printf("worker[%d] : count over 10. stealing give up.\n", index);
        queues[index].tried = 0;
        can_steal = 0;
      }
        // if(queues[next_index].front) printf("should be empty!!. left ele addr : %d\n", queues[next_index].front->inarr);
      }
      // printf("worker[%d] unlock next.\n", index);
      pthread_mutex_unlock(&qu_mutexs[next_index]);
      // printf("worker[%d] unlock self.\n", index);
      pthread_mutex_unlock(&qu_mutexs[index]); 
      // usleep(50000);
    }
    */
    
    

    if(get_job == 1){
      int * inarray = d.inarr;
      int * outarray = d.outarr;
      int startpoint = d.start;
      int worksize = d.size;
      
      for (int i=startpoint;i<worksize;i++){
        
        if(isPrime(inarray[i])){
          outarray[i] = 1;
        }
        else{
          outarray[i] = 0;
        }
        
      }
      d.flag_arr[d.flag_pos] = 1;

      
    }
  }
}